#!/usr/bin/env python3

"""
qlqw is the third iteration of the concept of the same name. This qlqw
is written in Python and uses pyinotify to drive its actions.
"""

import sys
import argparse
import os
import pathlib
import subprocess
import signal
import urllib.parse
import pyinotify

DOT_QUODLIBET = ".quodlibet"
CURRENT_FNAME = "current"
QUEUE_FNAME = "queue"
QUEUE_TMPNAME = QUEUE_FNAME + ".tmp"
QUEUE_OLDNAME = QUEUE_FNAME + ".old"

DEBUG = True


def system(cmd, timeout=13):
    """Run an external command."""
    proc = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )

    (out_, err_) = proc.communicate(timeout=timeout)
    out = out_.decode(encoding="UTF-8")
    err = err_.decode(encoding="UTF-8")

    sts = proc.wait(timeout=timeout)
    return (sts, out, err)

def ql_get_qld(fname=None):
    """
    Returns the path to ``~/.quodlibet;'' accepts an additional argument
    to join with the return value.
    """
    home_dir = str(pathlib.Path.home())
    if fname:
        return os.path.join(home_dir, DOT_QUODLIBET, fname)
    return os.path.join(home_dir, DOT_QUODLIBET)

def ql_clear_old_queue():
    try:
        os.unlink(ql_get_qld(QUEUE_OLDNAME))
    except FileNotFoundError:
        pass

def signal_handler(signum, stfr):
    raise QlStatusError("received signal {}.".format(signum))

def init_signals():
    for sig in (signal.SIGHUP, signal.SIGINT, signal.SIGTERM):
        signal.signal(sig, signal_handler)


class QlStatusError(OSError):
    pass


class QlQueue(object):

    PRINT = "quodlibet --print-queue"
    FPFX = "file://"

    def __init__(self):
        self.nofinal = True
        self.tmpq = ql_get_qld(QUEUE_TMPNAME)
        ql_clear_old_queue()

    def __post_process(self, stdout):
        unurl = urllib.parse.unquote(stdout)
        unpfx = [line[len(self.FPFX):] for line in unurl.splitlines()]
        if DEBUG:
            unfound = [p for p in unpfx if not os.path.exists(p)]
            assert not unfound,\
                "Paths not found:\n\t{}".format("\n\t".join(unfound))
        return unpfx

    def fetch_queue(self):
        """
        Ask Quod Libet for the latest queue; return a list of files.
        Raise a QlStatusError if we find that Quod Libet has exited.
        """
        (sts, out, _) = system(self.PRINT.split())
        if sts:
            errfmt = "queue fetch QL call exited with code {}"
            raise QlStatusError(errfmt.format(sts))
        return self.__post_process(out)

    def commit_queue(self, arr):
        """
        Given a list of files to write to the queue,
        write all these files to a tmpfile.
        """
        with open(self.tmpq, "w") as fpt:
            for ent in arr:
                fpt.write(ent)
                fpt.write("\n")
        self.nofinal = False

    def finalize_queue(self):
        ql_clear_old_queue()
        curr_queue = ql_get_qld(QUEUE_FNAME)
        old_queue = ql_get_qld(QUEUE_OLDNAME)

        os.link(curr_queue, old_queue)
        try:
            os.rename(self.tmpq, curr_queue)
        except FileNotFoundError:
            pass


class ProcessQlCurrent(pyinotify.ProcessEvent):
    """Basic class to field inotify events on QL."""
    def my_init(self, ql_queue=None):
        """Takes an instance of QlQueue for itself."""
        if ql_queue is None:
            self.ql_queue = QlQueue()
        else:
            self.ql_queue = ql_queue

    def process_IN_MODIFY(self, event):
        """Act if the ``current'' file was modified."""
        if event.name != CURRENT_FNAME:
            return
        queue_state = self.ql_queue.fetch_queue()
        try:
            self.ql_queue.commit_queue(queue_state)
        except QlStatusError as e:
            self.ql_queue.nofinal = True
            raise


def main():
    """Initialize inotify and enter the main loop."""
    watch_path = ql_get_qld()
    mask = pyinotify.IN_MODIFY
    ql_queue = QlQueue()
    processor = ProcessQlCurrent(ql_queue=ql_queue)

    wama = pyinotify.WatchManager()
    notifier = pyinotify.Notifier(wama, processor)

    wama.add_watch(watch_path, mask)
    init_signals()
    try:
        notifier.loop()
    except QlStatusError as e:
        print(e)

    if not ql_queue.nofinal:
        ql_queue.finalize_queue()
    return 0

if __name__ == "__main__":
    sys.exit(main())

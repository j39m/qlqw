#! /usr/bin/env perl

use strict; 
use warnings; 
use Getopt::Std; 
# we need URI unescaping for Quod Libet's queue-printing style.
use URI::Escape; 

my %flags = (); 
getopt('', \%flags);

$main::help = (defined($flags{"h"}) ? 1 : 0);
$main::dry = (defined($flags{"n"}) ? 1 : 0);
$main::oneshot = (defined($flags{"o"}) ? 1 : 0);
$main::status = (defined($flags{"s"}) ? 1 : 0);

$SIG{"USR1"} = "catch_sigusr1";

my $username = $ENV{"LOGNAME"};
my $userhome = $ENV{"HOME"};
my $qp = join("/", $userhome, ".quodlibet", "queue");
$main::cp = join("/", $userhome, ".quodlibet", "config");

pqlqw_start_ql();

while (1) { # daemonize

    if ($main::help) {
        print "Have a look at the readme!"
        ." pqlqw doesn't require much explanation.\n";
        exit 0;
    }

    if ($main::status) {
        pqlqw_check_status();
        exit 0;
    }

    pqlqw_write_queue(); 
    pqlqw_write_current(); 

    if ($main::oneshot or $main::dry) { 
        exit 0; 
    } 

sleep(520);  # median song length in my library is ~459s

} # end infinite loop. Script's main scope ends here.



# start Quod Libet. Called at the beginning of the script for convenience.
sub pqlqw_start_ql {
    unless ($main::dry || $main::oneshot || $main::status ||
            !pqlqw_check_process("nobail")) {
        system("quodlibet &");
        sleep(13);              # pause; let it breathe
    }
    return 0;
}

# verify QL is running. this should be called before ANY 
# system call to quodlibet, though it's STILL not 100% safe. 
sub pqlqw_check_process { 

    my $bail = (@_);
    my $check_command = join(" ", "pgrep -u", $username, 
                             "quodlibet > /dev/null");

    my $returnzeroplz = system($check_command);
    if ($returnzeroplz) {
        if (defined($bail) && $bail) {
            return 1;
        }
        pqlqw_bail("Quod Libet isn't running!");
    } 
    return 0;
} 


# queue-writing subroutine. 
sub pqlqw_write_queue { 

    pqlqw_check_process(); 

    my @q_arr = split(/\n+/, `quodlibet --print-queue`);
    my @q_trm = ();
    for my $line (@q_arr) {
        $line = uri_unescape($line);
        push @q_trm, substr($line, 7);
    }

    my $q_contents = join("\n", @q_trm);
    if (!$q_contents) {
        pqlqw_bail("Empty queue.");
    }

    if ($main::dry) { 
        print "$q_contents" . "\n"; 
    } else { 
        open(my $q_file, ">", $qp) or die "couldn't open $qp\n"; 
        print $q_file "$q_contents" . "\n";
        close $q_file; 
    } 

} 


# reads information about currently playing song;
# returns the tuple
#       song length (int), 
#       song name (string),
# bailing out totally if things go wrong.
sub pqlqw_get_current_info {

    my $current_path = join ("/", $userhome, ".quodlibet", "current"); 
    open my $current_fp, "<", $current_path
        or die "Couldn't open \"$current_path!\"\n"; 

    # we now need extract the labels "~#length" and "~filename." 
    # If either of these appear, split on the delimiter "=" and 
    # grab the right-hand value. 
    my $songlength = 0; 
    my $current_name = ""; 

    foreach my $line (<$current_fp>) { 
        if ($line =~ m/^~#length=(.*)/) { 
            $songlength = $1; 
        } elsif ($line =~ m/^~filename=(.*)/) { 
            $current_name = $1; 
        } 
    } 
    if (!$current_name || !$songlength) {
        pqlqw_bail("Couldn't get currently playing song!");
    } 
    close $current_fp;

    return ($songlength, $current_name);
}

# commits information about currently playing song to config file.
sub pqlqw_write_current { 
    
    my ($songlength, $current_name) = pqlqw_get_current_info();

    pqlqw_check_process(); 

    my @position_arr = split(/\s+/, `quodlibet --status`);
    # the sixth item in here will be 0.0 < x < 1.0 and represents
    # how far along the song you are.
    my $position = $position_arr[5];

    if (!defined($position) or !$position) {
        pqlqw_bail("Couldn't determine currently-playing position!");
    }

    # the new seek position is in milliseconds, the product of the 
    # fractional position times the length of song, the whole quantity
    # expressed in an integer number of milliseconds.
    my $new_seek_pos = int($position * $songlength * 1000); 

    if ($main::dry) { 
        print "\n". "Now playing \"$current_name\" at $new_seek_pos"
            . " milliseconds.\n\n"; 
    } 

    # Open the config file and make a new one. 
    my $config_path = join("/", $userhome, ".quodlibet", "config"); 
    open(my $config_fp, "<", $config_path)
        or die "Couldn't open \"$config_path!\"\n"; 

    my $configtmp_path = join("/", $userhome, ".quodlibet", "config-modified"); 
    open(my $configtmp_fp, ">", $configtmp_path);

    # write the new config file. 
    foreach my $line (<$config_fp>) { 
        if ($line =~ m/^song /) { 
            print $configtmp_fp "song = $current_name\n"; 
        } elsif ($line =~ m/^seek /) { 
            print $configtmp_fp "seek = $new_seek_pos\n"; 
        } else { 
            print $configtmp_fp $line; 
        } 
    } 

    close $config_fp; 
    close $configtmp_fp; 

    unless ($main::dry) { 
        `mv -v $configtmp_path $config_path`;
    } 

} 


# SIGUSR1 handler. 
sub catch_sigusr1 { 
    pqlqw_write_queue(); 
    pqlqw_write_current(); 
    print STDERR "Caught SIGUSR1.\n"; 
} 

sub pqlqw_bail {
    my ($msg) = @_;

    print STDERR "pqlqw: fatal error - ";
    if (defined($msg) && $msg) {
        print STDERR "aborting: $msg\n";
    } else {
        print STDERR "aborting.\n";
    }
    exit 1;
}

# checks the current state of the player's on-disk config, including its queue
# and "now playing" states, and prints the results to stdout.
sub pqlqw_check_status {

    my @queue_head = ();
    my @queue_tail = ();
    my $qcl = 8; # queue component lengths = len(head) = len(tail)
    my $song = "";
    my $seek = 0;

    # slurp in the head and tail of the queue on disk
    open(my $qfp, "<", $qp)
        or die "couldn't open $qp\n";
    while (<$qfp>) {
        chomp($_);
        if (scalar(@queue_head) < $qcl) {
            push(@queue_head, $_);
        } else {
            push(@queue_tail, $_);
        }
        if (scalar(@queue_tail) > $qcl) {
            shift(@queue_tail);
        }
    }
    close($qfp);

    # print the head and tail of the queue on disk
    print("\n============= queue on disk =============\n\n");
    for my $qentry (@queue_head) {
        print("$qentry\n");
    }
    print(".............\n");
    for my $qentry (@queue_tail) {
        print("$qentry\n");
    }

    # slurp in the "song" and "seek" values from the config file on disk
    open(my $cfp, "<", $main::cp)
        or die "couldn't open $main::cp\n";
    while (<$cfp>) {
        if ($_ =~ m/^song = (.*)$/) {
            $song = $1;
        } elsif ($_ =~ m/^seek = (.*)$/) {
            $seek = $1;
        }
    }
    close($cfp);

    # print the "song" and "seek" values from the config file on disk
    print("\n============= song and seek on disk =============\n\n");
    print("song: $song\n");
    print("seek: $seek\n");
    print("\n");

    return 0;

}
